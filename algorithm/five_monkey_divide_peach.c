/*
(难度:高)题目：海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子凭据分为五份，多了一个，这只
猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了
一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，
问海滩上原来最少有多少个桃子？

思路:
1. 每次一只猴子吃掉一个并拿走五份中的一份，剩下的桃子便是4的倍数，因此可以从第五只猴子
分完后剩下的桃子数来逆推总桃子数。
2. 初始设置第五只猴子分到1一个，则剩下的桃子数x=4*1.
3. 获取每次分之前的桃子数为(x/4)*5+1，且该数为第四只猴子分完后的数量，也应该4的倍数。若不是，则说明j不对。
4.以此类推，计算出第五只，第四只，第三只，第二只，第一只猴子分之前的桃子数并保证他们都是4的倍数。
*/

#include<stdio.h>
int main(){
    int i;
    int j=1;//第五只猴子分的桃子，初始值为1
    int x;//桃子数
    while(1){
        x = 4*j;//每次循环x的初始值为j*4
        for(i=0;i<5;i++){
            if(x%4!=0) break; //每次分完后剩余的桃子数一定是4的倍数
            else{
                x = (x/4)*5+1;//获取每次分之前的桃子数
                printf("每次分之前的桃子数为x=%d\n",x);
            }
        }
        if(i==5) break;//退出循环条件
        j++;//遍历j从1开始进行穷举，直到得到符合条件的桃子数x
        printf("\nnext loop,init value:j=%d\n", j);
    }
    printf("原始桃子数x=%d,j=%d", x,j);
    return 0;
}