/*
(难度:高)题目：海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子凭据分为五份，多了一个，这只
猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了
一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，
问海滩上原来最少有多少个桃子？

思路:
分析:设海滩上原来有x个桃子，则
第一只猴子分完桃子之后剩下的桃子x1=x-1-(x-1)/5=(4*(x-1))/5
第二只猴子分完桃子之后剩下的桃子x2=x1-1-(x1-1)/5=(4*(x1-1))/5
第三只猴子分完桃子之后剩下的桃子x3=x2-1-(x2-1)/5=(4*(x2-1))/5
第四只猴子分完桃子之后剩下的桃子x4=x3-1-(x3-1)/5=(4*(x3-1))/5
第五只猴子分完桃子之后剩下的桃子x5=x4-1-(x4-1)/5=(4*(x4-1))/5

假设第五只猴子分得的桃子为1，五份则为5，即第5只猴子分完桃子后剩下的桃子为4

4/4*4+1=6  即6为第五只猴子开始分之前的桃子数，但是6%4!=0,即不满足当第四只猴子分完桃子后剩余桃子个数。

所以第五只猴子分得的桃子数不是1，那么从2开始穷举，直到满足每次所有条件为止。

————————————————
原文链接：https://blog.csdn.net/zdy8023/article/details/103862363

*/

#include<stdio.h>
int main(){
    int i;//循坏次数
    int j=1;//第五只猴子分的桃子，初始值为1
    int x;//原始桃子数
    while(1){
        x = 4*j;
        printf("第五只猴子分得桃子为%d个时，剩余桃子数为%d\n",j,x);
        for(i=0;i<5;){
            if(x%4!=0) break; 
            else{
                x = (x/4)*5+1;
                printf("第五只猴子分得桃子为%d个时，剩余桃子数为%d\n",j,x);
                i++;
            }
        }
        printf("\n");
        j++;
        if(i==5) break;
    }
    printf("原始桃子数为%d", x);
    return 0;
}